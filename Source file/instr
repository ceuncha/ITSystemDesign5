module Instruction_memory(pc, instOut);

    input [31:0] pc;
    output reg [31:0] instOut;
    reg [7:0] memory [0:1023]; // 1KB memory
    integer i;

    initial begin

        // Initialize all memory to 0
        for (i = 48; i < 1024; i = i + 1) begin
            memory[i] <= 8'b0;
        end
{memory[0], memory[1], memory[2], memory[3]} <= 32'b0000000_00100_01000_000_00111_0110011; // add x7, x8, x4
{memory[4], memory[5], memory[6], memory[7]} <= 32'b000000000001_00101_010_00100_0000011; // load x4, 1(x5)
{memory[8], memory[9], memory[10], memory[11]} <= 32'b0000000_00100_00001_000_00110_0110011; // add x6, x1, x4
{memory[12], memory[13], memory[14], memory[15]} <= 32'b0100000_00010_00011_000_00001_0110011; // sub x1, x3, x2
{memory[16], memory[17], memory[18], memory[19]} <= 32'b0000000_01000_00111_000_00100_0110011; // add x4, x7, x8

// sub x9, x9, x1
{memory[20], memory[21], memory[22], memory[23]} <= 32'b0100000_00001_01001_000_01001_0110011; // sub x9, x9, x1

// beq x9, x1, -20 (20 / 4 = 5, so -20 / 4 = -5 in the offset field)
{memory[24], memory[25], memory[26], memory[27]} <= 32'b1111111_00001_01001_001_01101_1100011; // bne x9, x1, -20

// Following instructions after beq
{memory[28], memory[29], memory[30], memory[31]} <= 32'b0100000_00101_01010_000_01001_0110011; // sub x9, x10, x5
{memory[32], memory[33], memory[34], memory[35]} <= 32'b0000000_01100_01011_000_01010_0110011; // add x10, x11, x12
{memory[36], memory[37], memory[38], memory[39]} <= 32'b0000000_01111_01110_000_01101_0110011; // add x13, x14, x15
{memory[40], memory[41], memory[42], memory[43]} <= 32'b0000000_10010_10001_000_10000_0110011; // add x16, x17, x18
{memory[44], memory[45], memory[46], memory[47]} <= 32'b0000000_10101_10100_000_10011_0110011; // add x19, x20, x21
    end

    always @ (*) begin
        instOut <= {memory[pc], memory[pc+1], memory[pc+2], memory[pc+3]};
    end

endmodule
