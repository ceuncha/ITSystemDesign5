module branch_unit(
    input [6:0] opcode,      // 명령어 유형을 결정하는 opcode 신호
    input [2:0] funct3,      // 분기 명령어의 종류를 결정하는 funct3 신호
    input [31:0] immediate,  // 명령어에서 추출한 즉시값
    input [31:0] PC,         // 현재 프로그램 카운터 값
    input [31:0] RData1,     // JALR 동작을 위한 rs1 값 (JALR 점프 위치: rs1+imm)
    input [5:0] compare_out, // 조건부 분기 판정을 위한 comparator 비교 값
    output reg [31:0] PC_Branch, // 분기 또는 점프에 의해 변경될 PC 값
    output reg PCSrc,        // 최종적으로 분기 또는 점프 발생 시 1, 아니면 0
    output reg [31:0] Rd_data,   // LUI, AUIPC, JAL, JALR 명령어에서 Rd에 쓰이는 값
    output reg IF_ID_Flush   // 분기 또는 점프 실행 시 IF/ID 파이프라인 레지스터를 flush할 신호
);

always @(*) begin
    // 기본값 설정
    PCSrc = 0;
    PC_Branch = 32'b0;
    Rd_data = 32'b0;
    IF_ID_Flush = 0; // 기본적으로 flush하지 않음
    
    case(opcode)
        7'b0110111: begin // LUI
            Rd_data = immediate;
        end
        7'b0010111: begin // AUIPC
            Rd_data = PC + immediate;
        end
        7'b1101111: begin // JAL
            PCSrc = 1;
            PC_Branch = PC + immediate;
            Rd_data = PC + 4;
            IF_ID_Flush = 1; // flush 신호 활성화
        end
        7'b1100111: begin // JALR
            PCSrc = 1;
            PC_Branch = (RData1 + immediate) & ~1; // Ensure the LSB is 0 for alignment
            Rd_data = PC + 4;
            IF_ID_Flush = 1; // flush 신호 활성화
        end
        7'b1100011: begin // Branch Instructions
            case (funct3)
                3'b000: PCSrc = (compare_out == 3'b000); // BEQ
                3'b001: PCSrc = (compare_out == 3'b001); // BNE
                3'b100: PCSrc = (compare_out == 3'b010); // BLT
                3'b101: PCSrc = (compare_out == 3'b011); // BGE
                3'b110: PCSrc = (compare_out == 3'b100); // BLTU
                3'b111: PCSrc = (compare_out == 3'b101); // BGEU
            endcase
            if (PCSrc) begin
                PC_Branch = PC + immediate;
                IF_ID_Flush = 1; // flush 신호 활성화
            end
        end
    endcase
end

endmodule
